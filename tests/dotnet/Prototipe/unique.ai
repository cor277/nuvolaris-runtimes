----- START OF MicroAPIClass\FncDto.cs -----
using Dapper;
using Npgsql;
using Microsoft.Extensions.Configuration;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace OW
{
    // DTO class to represent functionalities.
    public class FncDto
    {
        // Default property initializers to assign default values.
        public Guid Id { get; set; } = Guid.NewGuid();
        public string? Descr { get; set; }
        public bool? Enabled { get; set; } = true;
        public DateTime? UpdDate { get; set; } = DateTime.Now;

        // Override ToString for a readable representation of the object.
        public override string ToString()
        {
            return $"Id: {Id}, Descr: {Descr}, Enabled: {Enabled}, UpdDate: {UpdDate}";
        }
    }

    // Repository class to manage database operations.
    public class FncDtoRepository
    {
        private string? actionName;
        public string? tableName { get; set; }
        private readonly string _connectionString;

        private IConfiguration config;

        // Costruttore del repository
        public FncDtoRepository(string argsJson)
        {
            config = new ConfigurationBuilder()
                .SetBasePath(Directory.GetCurrentDirectory())
                .AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
                .Build();

            dynamic? args = argsJson != null ? JsonConvert.DeserializeObject(argsJson) : null;
            string server = config["DB_SERVER"] ?? "nuvolaris-postgres";
            string database = config["DB_NAME"] ?? "nuvolaris";
            string port = config["DB_PORT"] ?? "5432";
            string user = config["DB_USER"] ?? args?.DB_USER ?? string.Empty;
            string password = config["DB_PASSWORD"] ?? args?.DB_PASSWORD ?? string.Empty;
            actionName = config["ACTION_NAME"] ?? args?.ACTION_NAME ?? string.Empty;
            tableName = actionName + "_Dto";

            _connectionString = $"SERVER={server};PORT={port};DATABASE={database};UID={user};PWD={password};";
        }

        // Opens a new connection and ensures it's ready for use.
        private async Task<NpgsqlConnection> OpenConnectionAsync()
        {
            var connection = new NpgsqlConnection(_connectionString);
            await connection.OpenAsync();
            return connection;
        }

        // Truncate a table if it doesn't exist in the database.
        public async Task TruncateTableAsync()
        {
            var createTableQuery = $@"
                TRUNCATE TABLE {actionName}_Dto;";

            using (var connection = await OpenConnectionAsync())
            {
                await connection.ExecuteAsync(createTableQuery);
            }
        }

        // Drop a table if it doesn't exist in the database.
        public async Task DropTableAsync()
        {
            var createTableQuery = $@"
                DROP TABLE {actionName}_Dto;";

            using (var connection = await OpenConnectionAsync())
            {
                await connection.ExecuteAsync(createTableQuery);
            }
        }

                // Creates a table if it doesn't exist in the database.
        public async Task CreateTableAsync()
        {
            var createTableQuery = $@"
                CREATE TABLE IF NOT EXISTS {actionName}_Dto (
                    Id UUID PRIMARY KEY,
                    Descr TEXT,
                    Enabled BOOLEAN,
                    UpdDate TIMESTAMP
                );";

            using (var connection = await OpenConnectionAsync())
            {
                await connection.ExecuteAsync(createTableQuery);
            }
        }

        // Executes a given query against the database.
        public async Task<IEnumerable<dynamic>> ExecuteQueryAsync(string query)
        {
            using (var connection = await OpenConnectionAsync())
            {
                return await connection.QueryAsync(query);
            }
        }

        // Retrieves all records from the specified table.
        public async Task<IEnumerable<FncDto>> GetAllAsync()
        {
            using (var connection = await OpenConnectionAsync())
            {
                return await connection.QueryAsync<FncDto>($"SELECT * FROM {tableName}");
            }
        }

        // Fetches a single record by its ID.
        public async Task<FncDto> GetByIdAsync(Guid id)
        {
            using (var connection = await OpenConnectionAsync())
            {
                var result = await connection.QueryFirstOrDefaultAsync<FncDto>(
                    $"SELECT * FROM {tableName} WHERE Id = @Id", new { Id = id });

                return result!;
            }
        }

        // Inserts a new record into the specified table.
        public async Task<string> InsertAsync(FncDto dto)
        {
            using (var connection = await OpenConnectionAsync())
            {
                await connection.ExecuteAsync(
                    $"INSERT INTO {tableName} (Id, Descr, Enabled, UpdDate) VALUES (@Id, @Descr, @Enabled, @UpdDate)", dto);
                return dto.Id.ToString();
            }
        }

        // Updates an existing record in the specified table.
        public async Task<string> UpdateAsync(FncDto dto)
        {
            using (var connection = await OpenConnectionAsync())
            {
                await connection.ExecuteAsync(
                    $"UPDATE {tableName} SET Descr = @Descr, Enabled = @Enabled, UpdDate = @UpdDate WHERE Id = @Id", dto);
                return dto.Id.ToString();
            }
        }

        // Deletes a record by its ID from the specified table.
        public async Task<string> DeleteAsync(Guid id)
        {
            using (var connection = await OpenConnectionAsync())
            {
                await connection.ExecuteAsync(
                    $"DELETE FROM {tableName} WHERE Id = @Id", new { Id = id });
                return id.ToString();
            }
        }
    }
}
----- END OF MicroAPIClass\FncDto.cs -----
----- START OF MicroAPIClass\MyMicroservicesOpenWhiskExecutor.cs -----
using Newtonsoft.Json.Linq;
using OW;
using System;
using System.Collections;
using System.Threading.Tasks;

namespace OWMicroservices
{
    // Class to perform OpenWhisk operations
    [AuthUri("/AUTH/authorize")]
    [Server("https://nuvolaris.dynamicsconsulting.it/gateway")]
    [Package("PrototipeMicroservices")]
    [Action("PrototipeFNC")]
    [Route("/prototipe/api/v1/")]
    public class MyMicroservicesOpenWhiskExecutor
    {
        // Static repository instance
        private static FncDtoRepository? _repository;

        // Main method to execute operations based on the HTTP method
        public static JObject Execute(JObject args)
        {
            try
            {
                _repository = new FncDtoRepository(args?.ToString() ?? string.Empty);
                FncDto? fncDto = null;
                // Configure APISIX if required
                var setupResult = PluginConfig.SetupApisixIfRequired(args!).GetAwaiter().GetResult();
                if (setupResult is not null && setupResult["error"] is null)
                {
                    if (setupResult["result"] is null)
                    {
                        return AddResultInBody(setupResult);
                    }

                }else
                {
                    if (setupResult is not null && setupResult["error"] is not null)
                    return AddResultInBody(setupResult);
                    else
                    {
                        return AddResultInBody(new JObject
                        {
                            ["error"] = "Setup APISIX non riuscito",
                            ["message"] = "Setup APISIX non riuscito",
                            ["args"] = args
                        });
                    }
                }

                if (args != null)
                {
                    fncDto = args.ToObject<FncDto>();
                }



                string? httpMethod = args?["method"]?.ToString().ToUpper();

                JObject result = httpMethod switch
                {
                    // Handles different HTTP operations using a switch expression, awaited asynchronously
                    "GET" => MyMicroservicesVerbsModel.HandleGet(Guid.Parse(args!["id"]!.ToString()), _repository!).GetAwaiter().GetResult(),
                    "PUT" => MyMicroservicesVerbsModel.HandlePut(fncDto! , _repository!).GetAwaiter().GetResult(),
                    "DELETE" => MyMicroservicesVerbsModel.HandleDelete(Guid.Parse(args!["id"]!.ToString()) , _repository!).GetAwaiter().GetResult(),
                    "PATCH" => MyMicroservicesVerbsModel.HandlePatch(fncDto!, _repository!).GetAwaiter().GetResult(),
                    "POST" => HandlePost(args!).GetAwaiter().GetResult(),
                    // Default case for unsupported HTTP methods
                    _ => new JObject
                    {
                        ["error"] = "HTTP method not supported" + httpMethod,
                        ["args"] = args
                    },
                };

                // Wraps the result in a response body
                return AddResultInBody(result);
            }
            catch (Exception ex)
            {
                // Handles exceptions during execution and provides detailed error message
                return AddResultInBody(new JObject
                {
                    ["error"] = $"Error during action execution: {ex.Message}, line: {(ex.StackTrace != null ? ExtractLineNumber(ex.StackTrace) : "N/A")}, args: {args}"
                });
            }
        }

        // Handles the POST method by determining which action should be taken based on additional parameters.
        private static async Task<JObject> HandlePost(JObject args)
        {
            // Safe navigation used to prevent null reference issues
            string? createTable = args["createtable"]?.ToString().ToUpper();
            string? truncateTable = args["truncatetable"]?.ToString().ToUpper();
            string? dropTable = args["droptable"]?.ToString().ToUpper();
            string? query = args["query"]?.ToString();

            // Check if the 'createtable' command is present and equals 'YES'
            if (createTable == "YES")
            {
                // Handle table creation
                return await MyMicroservicesVerbsModel.HandleCreateTable(_repository!);
            }
            else  if (dropTable == "YES")
            {
                // Handle table deletion
                return await MyMicroservicesVerbsModel.HandleDropTable(_repository!);
            }
            else if (truncateTable == "YES")
            {
                // Handle table truncation
                return await MyMicroservicesVerbsModel.HandleTruncateTable(_repository!);
            }
            else if (query != null)
            {
                // Handle query execution if a query parameter is provided
                return await MyMicroservicesVerbsModel.HandleExecuteQuery(args, _repository!);
            }

            // If no known commands are found, return an error indicating that the POST method is not supported
            return new JObject
            {
                ["error"] = "POST method not supported",
                ["message"] = "Metodo POST non supportato",
                ["args"] = args
            };
        }

        // Extracts line number from stack trace string safely
        private static string ExtractLineNumber(string stackTrace)
        {
            return stackTrace?.Substring(stackTrace.LastIndexOf("line") + 4) ?? "N/A";
        }

        // Private method not exposed on OpenWhisk apisix to get the list of environment variables
        public static JObject GetEnvVars()
        {
            var envVars = Environment.GetEnvironmentVariables();
            JObject result = new JObject();

            // Iterating over each entry in environment variables dictionary
            foreach (DictionaryEntry entry in envVars)
            {
                // Casting key and value of DictionaryEntry to strings and adding them to the result object
                var key = entry.Key.ToString();
                var value = entry.Value?.ToString() ?? string.Empty;
                #pragma warning disable CS8604 // Possible null reference argument.
                    result[key] = value!;
                #pragma warning restore CS8604 // Possible null reference argument.
            }

            return result;
        }

        // Adds the provided JObject as the 'body' of the response payload
        private static JObject AddResultInBody(JObject body)
        {
            // Encapsulates the body within another JObject under the 'body' key
            return new JObject { ["body"] = body };
        }
    }
}
----- END OF MicroAPIClass\MyMicroservicesOpenWhiskExecutor.cs -----
----- START OF MicroAPIClass\MyMicroservicesVerbsModel.cs -----
using Newtonsoft.Json.Linq;
using OW;
using System;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace OWMicroservices
{
    /// <summary>
    /// Class for handling various HTTP operations.
    /// </summary>
    public static class MyMicroservicesVerbsModel
    {
        /// <summary>
        /// Handles the creation of a table.
        /// </summary>
        public static async Task<JObject> HandleCreateTable(FncDtoRepository repository)
        {
            await repository.CreateTableAsync();
            return JObject.FromObject(new { message = "Tabella creata: " + repository.tableName });
        }

        /// <summary>
        /// Handles the truncate of a table.
        /// </summary>
        public static async Task<JObject> HandleTruncateTable(FncDtoRepository repository)
        {
            await repository.TruncateTableAsync();
            return JObject.FromObject(new { message = "Tabella troncata: " + repository.tableName });
        }

        /// <summary>
        /// Handles the drop of a table.
        /// </summary>
        public static async Task<JObject> HandleDropTable(FncDtoRepository repository)
        {
            await repository.DropTableAsync();
            return JObject.FromObject(new { message = "Tabella droppata: " + repository.tableName });
        }

        /// <summary>
        /// Executes a specified query.
        /// </summary>
        public static async Task<JObject> HandleExecuteQuery(JObject args, FncDtoRepository repository)
        {
            return await TryExecuteAsync(
                async () =>
                {
                    var query = args["query"]?.ToString();
                    if (query != null)
                    {
                        // Check if the query is a SELECT statement
                        if (!IsSelectQuery(query))
                        {
                            throw new Exception("Only SELECT queries are allowed");
                        }

                        var queryResult = await repository.ExecuteQueryAsync(query);
                        if (queryResult != null)
                        {
                            return JToken.FromObject(queryResult);
                        }
                        else
                        {
                            return JObject.FromObject(new { message = "La query non ha generato risultati" });
                        }
                    }
                    else
                    {
                        throw new ArgumentNullException("query", "Query is null");
                    }
                },
                "Esecuzione della query completata",
                "Errore durante l'esecuzione della query: "
            );
        }

        private static bool IsSelectQuery(string query)
        {
            // Implement your logic to check if the query is a SELECT statement
            // You can use regular expressions or parsing libraries to perform this check
            // Here's a simple example using regular expressions:
            return Regex.IsMatch(query, @"^\s*SELECT", RegexOptions.IgnoreCase);
        }

        /// <summary>
        /// Handles the GET operation.
        /// </summary>
        public static async Task<JObject> HandleGet(Guid? id, FncDtoRepository repository)
        {
            return await TryExecuteAsync(
                async () =>
                {
                    if (id != null)
                    {
                        #pragma warning disable CS8602 // Dereference of a possibly null reference.
                            var result = await repository.GetByIdAsync((Guid)id);
                        #pragma warning restore CS8602 // Dereference of a possibly null reference.
                        return result != null ? JObject.FromObject(result) : throw new Exception("Id not found");
                    }
                    else
                    {
                        throw new ArgumentNullException("id", "Id is null");
                    }
                },
                "Operazione GET completata",
                "Errore durante l'operazione GET: "
            );
        }

        /// <summary>
        /// Handles the PUT operation.
        /// </summary>
        public static async Task<JObject> HandlePut(FncDto dto, FncDtoRepository repository)
        {
            return await TryExecuteAsync(
                async () =>
                {
                    await repository.InsertAsync(dto);
                    return JObject.FromObject(new { message = "Inserimento completato id: " + dto.Id.ToString() });
                },
                "Inserimento completato",
                "Errore durante l'inserimento: ",
                dto
            );
        }

        /// <summary>
        /// Handles the DELETE operation.
        /// </summary>
        public static async Task<JObject> HandleDelete(Guid id, FncDtoRepository repository)
        {
            return await TryExecuteAsync(
                async () =>
                {
                    await repository.DeleteAsync(id);
                    return JObject.FromObject(new { message = "Record eliminato id: " + id.ToString() });
                },
                "Eliminazione completata",
                "Errore durante l'eliminazione: "
            );
        }

        /// <summary>
        /// Handles the PATCH operation.
        /// </summary>
        public static async Task<JObject> HandlePatch(FncDto dto, FncDtoRepository repository)
        {
            return await TryExecuteAsync(
                async () =>
                {
                    var existingRecord = await repository.GetByIdAsync(dto.Id);
                    if (existingRecord != null)
                    {
                        await repository.UpdateAsync(dto);
                    }
                    else
                    {
                        await repository.InsertAsync(dto);
                    }
                    return JObject.FromObject(new { message = "Upsert completata id: " + dto.Id.ToString() });
                },
                "Upsert completato id: " + dto.Id.ToString() + "",
                "Errore durante l'esecuzione dell'upsert: ",
                dto
            );
        }

        /// <summary>
        /// Attempts to execute an asynchronous action, returning a JSON result or error message.
        /// </summary>
        private static async Task<JObject> TryExecuteAsync(Func<Task<JToken>> action, string successMessage, string errorMessage, object? argument = null)
        {
            try
            {
                // Ensures that DTO is valid before executing the action.
                if (argument is null || argument as FncDto != null)
                {
                    var result = await action();
                    // If a result is returned from the action, use it; otherwise, return the success message.
                    return result != null ? new JObject { ["result"] = result } : new JObject { ["result"] = successMessage };
                }

                // Returns an error if the DTO is null.
                return new JObject { ["error"] = "Il DTO è nullo" };
            }
            catch (Exception ex)
            {
                // Captures and returns any exception messages encountered during execution.
                return new JObject { ["error"] = $"{errorMessage}{ex.Message}" };
            }
        }
    }
}
----- END OF MicroAPIClass\MyMicroservicesVerbsModel.cs -----
----- START OF MicroAPIClass\Program.cs -----
using Newtonsoft.Json.Linq; // Used for JSON object manipulation.
using OW; // Internal library for working with OpenWhisk.
using OWMicroservices; // Internal library for working with microservices.


public static class Program
{
    // The entry point of the application.
    public static void Main(string[] args)
    {
        // Check if command line arguments are provided.
        if (args.Length > 0)
        {
            // Create a generator instance to produce manifest files.
            var generator = new ManifestGenerator("template.yaml", "manifest.yml", "invoke.ps1");

            // Process command based on the first argument, doing case-insensitive comparison.
            switch (args[0].ToLowerInvariant())
            {
                case "generate":
                    // Call the generate method to create manifest file from template.
                    generator.Generate();
                    break;
                case "test":
                    // Execute test commands using the provided arguments. Debug configuration is considered.
                    RunTests(args);
                    break;
                default:
                    // Inform the user about unrecognized commands and suggest available options.
                    Console.WriteLine("Unrecognized argument. Use 'generate' to generate the file or 'test' to execute tests.");
                    break;
            }
        }
        else
        {
            // Notify the user when no arguments are passed to the program.
            Console.WriteLine("No arguments provided. Use 'generate' to generate the file or 'test' to execute tests.");
        }
    }

    // Method to encapsulate test execution logic.
    private static void RunTests(string[] args)
    {
        // Triggers a breakpoint in the attached debugger for manual inspection.
        System.Diagnostics.Debugger.Break();

        // Convert command line arguments into a dictionary for further processing.
        var dictionary = ParseArgumentsToDictionary(args);

        try
        {
            // Attempt to execute the microservice action using parsed arguments as input.
            _ = MyMicroservicesOpenWhiskExecutor.Execute(JObject.FromObject(dictionary));
        }
        catch (Exception ex)
        {
            // Catch any exceptions and output the error message to the console's standard error stream.
            Console.Error.WriteLine($"An error occurred while executing tests: {ex.Message}");
        }
    }

    // Converts an array of command line arguments into a dictionary.
    private static Dictionary<string, string> ParseArgumentsToDictionary(string[] args)
    {
        // Initialize a case-insensitive dictionary to store argument key-value pairs.
        var dictionary = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        // Iterate through each argument and split it into a pair.
        foreach (var arg in args)
        {
            var splitArg = arg.Split(new char[] { '=' }, 2); // Split the string into exactly two substrings.
            if (splitArg.Length == 2)
            {
                // Add the split key and value to the dictionary if we have exactly two elements.
                dictionary[splitArg[0]] = splitArg[1];
            }
        }

        // Return the populated dictionary back to the caller.
        return dictionary;
    }
}
----- END OF MicroAPIClass\Program.cs -----
----- START OF OWUtils\ApisixPluginConfig.cs -----
using Newtonsoft.Json.Linq;
using OWMicroservices;
using System;
using System.Reflection;
using System.Threading.Tasks;

// Define the namespace for Organziation Works (OW)
namespace OW
{
    // PluginConfig class to handle Plugin Configuration and setup specific tasks.
    public class PluginConfig
    {
        // Properties are unchanged as their usage is not clear from the snippet.

        /// <summary>
        /// Asynchronously sets up the APIs in APISIX if required.
        /// </summary>
        /// <param name="args">The JObject containing the necessary arguments.</param>
        /// <returns>A JObject indicating the success or error state of the operation.</returns>
        public static async Task<JObject> SetupApisixIfRequired(JObject args)
        {
            // Retrieve all custom attributes associated with MyMicroservicesOpenWhiskExecutor class at once.
            var attributes = typeof(MyMicroservicesOpenWhiskExecutor).GetCustomAttributes();

            // Extracting specific attribute values for action name, package name, and route name
            string actionName = OpenWhiskUtilities.GetAttributeValue("Action");
            string packageName = OpenWhiskUtilities.GetAttributeValue("Package");
            string routeName = OpenWhiskUtilities.GetAttributeValue("Route");
            string authUri = OpenWhiskUtilities.GetAttributeValue("AuthUri");
            string server = OpenWhiskUtilities.GetAttributeValue("Server");

            try
            {
                // Check if 'setupapisix' argument is provided and equals "True"
                if (args["setupapisix"]?.ToString().ToUpper() == "TRUE")
                {
                    // Prepare descriptor based on extracted attributes and additional settings
                    var descriptor = new OpenWhiskFunctionDescriptor
                    (
                        httpMethods: new[] { "GET", "PUT", "DELETE", "PATCH", "POST" },
                        route: routeName,
                        name: $"{packageName}-{actionName}",
                        package: packageName,
                        action: actionName,
                        result: true,
                        sslVerify: false,
                        timeout: 60000,
                        apiKey: args["API_KEY"]?.ToString() ?? "ERROR_API_KEY_NOT_FOUND",
                        server: server,
                        authUri: authUri
                    );

                    // Execute the setup routine with the prepared descriptor
                    return await OpenWhiskUtilities.SetupRouteInApisix(descriptor);
                }

                // If setup is not required, return a simple JObject indicating it.
                return JObject.FromObject(new { result = "Setup non richiesto" });
            }
            catch (Exception ex)
            {
                // In case of an exception, return error information including the message and line number from the stack trace.
                return JObject.FromObject(new
                {
                    error = $"Errore durante l'esecuzione del metodo SetupApisixIfRequired: {ex.Message}, riga: {OpenWhiskUtilities.GetLineNumberFromStackTrace(ex)}"
                });
            }
        }
    }
}
----- END OF OWUtils\ApisixPluginConfig.cs -----
----- START OF OWUtils\ManifestGenerator.cs -----
using System.Diagnostics;
using System.Reflection;
using System.Runtime.Versioning;
using OWMicroservices;

namespace OW
{
    public class ManifestGenerator
    {
        private readonly string _YAMLtemplatePath;
        private readonly string _YAMLoutputPath;

        private readonly string _PS1InvoketemplatePath;

        // Constructor to initialize the paths needed for the generator.
        public ManifestGenerator(string YAMLtemplatePath, string YAMLoutputPath, string PS1InvoketemplatePath)
        {
            _YAMLtemplatePath = YAMLtemplatePath;
            _YAMLoutputPath = YAMLoutputPath;
            _PS1InvoketemplatePath = PS1InvoketemplatePath;
        }

        // Main method that generates the manifest based on the assembly information and template file.
        public void Generate()
        {
            Assembly entryAssembly = Assembly.GetExecutingAssembly();
            Type type = typeof(MyMicroservicesOpenWhiskExecutor);

            // Retrieve all custom attributes associated with MyMicroservicesOpenWhiskExecutor class at once.
            var attributes = typeof(MyMicroservicesOpenWhiskExecutor).GetCustomAttributes();

            // Fetch necessary custom attribute values from the assembly and provided type.
            // Extracting specific attribute values for action name, package name, and route name
            string actionName = OpenWhiskUtilities.GetAttributeValue("Action");
            string packageName = OpenWhiskUtilities.GetAttributeValue("Package");

            string runtimeVersion = entryAssembly?.GetCustomAttribute<TargetFrameworkAttribute>()?.FrameworkName?.Split('=')[1] ?? string.Empty; 
            string dllName = entryAssembly?.GetName()?.Name ?? string.Empty;
            var publicClassType = entryAssembly?.GetTypes().FirstOrDefault(t => t.GetMethods().Any(method => method.Name == "Execute"));

            string template = File.ReadAllText(_YAMLtemplatePath);

            // Replace placeholders in the template if present.
            if (publicClassType != null)
            {
                ProcessTemplatePlaceholders(ref template, publicClassType, runtimeVersion, dllName, actionName, packageName);
            }
            // Write the modified content back to the output file.
            File.WriteAllText(_YAMLoutputPath, template);

            string invokeTemplate = File.ReadAllText(_PS1InvoketemplatePath);

            ProcessTemplatePlaceholders(ref invokeTemplate, packageName, actionName);
            // Generate the invoke.ps1 script with the appropriate package and action names.

            File.WriteAllText("invoke.ps1", invokeTemplate);
        }

        // Processes the template placeholders and replaces them with actual values.
        private void ProcessTemplatePlaceholders(ref string template, Type publicClassType, string runtimeVersion, 
                                            string dllName, string actionName, string packageName)
        {
            // Only retrieve process data if placeholders exist in the template.
            if (template.Contains("##db"))
            {
                string[] processOutput = RetrieveProcessOutputLines("/c nuv debug status | grep postgres");
                var dbInfo = ParseDatabaseInfo(processOutput);
                template = ReplaceDatabasePlaceholders(template, dbInfo);
            }

            if (template.Contains("##auth##"))
            {
                // Fetch authentication details from external command output.
                string auth = RetrieveProcessOutputLine("/c nuv -wsk -i property get --auth").Split('\t')[2];
                template = template.Replace("##auth##", auth.Trim());
            }

            // Replace placeholders related to the assembly and custom attributes.
            template = template.Replace("##runtimeversion##", runtimeVersion)
                               .Replace("##name##", actionName)
                               .Replace("##dllzip##", $"{dllName}.zip")
                               .Replace("##dllname##", dllName)
                               .Replace("##projectname##", packageName)
                               .Replace("##Programcsnamespace##", publicClassType?.Namespace ?? string.Empty)
                               .Replace("##publicclassname##", publicClassType?.Name ?? string.Empty);
        }

        private void ProcessTemplatePlaceholders(ref string template, string packageName, string actionName)
        {
            // Only retrieve process data if placeholders exist in the template.

            if (template.Contains("##packagename##"))
            {
                template = template.Replace("##packagename##", packageName.Trim());
            }

            if (template.Contains("##actionname##"))
            {
                template = template.Replace("##actionname##", actionName.Trim());
            }

        }

        // Replaces database related placeholders in the template string.
        private string ReplaceDatabasePlaceholders(string template, (string Password, string User, string Host, string Port, string Name) dbInfo)
        {
            return template.Replace("##dbpassword##", dbInfo.Password)
                           .Replace("##dbuser##", dbInfo.User)
                           .Replace("##dbhost##", dbInfo.Host.Split('.')[0])
                           .Replace("##dbport##", dbInfo.Port.Replace("\"", string.Empty).Trim())
                           .Replace("##dbname##", dbInfo.Name);
        }

        // Runs a command line process and returns the standard output as an array of lines.
        private string[] RetrieveProcessOutputLines(string arguments)
        {
            using var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = "cmd.exe",
                    Arguments = arguments,
                    RedirectStandardOutput = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();
            var output = process.StandardOutput.ReadToEnd();
            process.WaitForExit();
            
            return output.Split('\n');
        }

        // Gets a single line from the standard output of a command line process.
        private string RetrieveProcessOutputLine(string arguments)
        {
            return RetrieveProcessOutputLines(arguments).First();
        }

        // Parses out relevant database information from an array of strings containing command output.
        private (string Password, string User, string Host, string Port, string Name) ParseDatabaseInfo(string[] lines)
        {
            string FindValue(string key) => lines.FirstOrDefault(line => line.Contains(key))?.Split(':')[1].Trim() ?? string.Empty;
            return (
                Password: FindValue("postgres_password"),
                User: FindValue("postgres_username"),
                Host: FindValue("postgres_host"),
                Port: FindValue("postgres_port"),
                Name: FindValue("postgres_database")
            );
        }
    }
}
----- END OF OWUtils\ManifestGenerator.cs -----
----- START OF OWUtils\OpenWhiskFunctionDescriptor.cs -----
namespace OW
{
    /// <summary>
    /// Represents a descriptor for an OpenWhisk function, detailing how it can be accessed and invoked.
    /// </summary>
    public class OpenWhiskFunctionDescriptor
    {
        // An array of HTTP methods supported by the OpenWhisk action.
        public string[] HttpMethods { get; set; }

        // The route pattern that this OpenWhisk action responds to.
        public string Route { get; set; }

        // The name identifier of the OpenWhisk action.
        public string Name { get; set; }

        // The package where the OpenWhisk action is located.
        public string Package { get; set; }

        // The specific action to execute within the OpenWhisk framework.
        public string Action { get; set; }

        // A flag indicating whether only the result of the action should be returned without the full OpenWhisk metadata.
        public bool Result { get; set; }

        // A flag indicating whether SSL verification should be performed on requests.
        public bool SslVerify { get; set; }

        // The timeout for the OpenWhisk action invocation in milliseconds.
        public int Timeout { get; set; }

        // The API key to authenticate against the OpenWhisk API.
        public string ApiKey { get; set; }

        // The server path where host api is located.
        public string Server { get; set; }

        // The authorization path where host api is located.
        public string AuthUri { get; set; }

        /// <summary>
        /// Initializes a new instance of the OpenWhiskFunctionDescriptor class with specified details.
        /// </summary>
        /// <param name="httpMethods">An array of supported HTTP methods.</param>
        /// <param name="route">The route pattern to match.</param>
        /// <param name="name">The action's name.</param>
        /// <param name="package">The package containing the action.</param>
        /// <param name="action">The specific action to call.</param>
        /// <param name="result">Flag for returning only action results.</param>
        /// <param name="sslVerify">Flag for SSL verification requirement.</param>
        /// <param name="timeout">Timeout duration for the action.</param>
        /// <param name="apiKey">API key for authentication.</param>
        /// <param name="server">Server path for host api.</param>
        /// <param name="authUri">Authorization path for host api.</param>
        public OpenWhiskFunctionDescriptor(
            string[] httpMethods,
            string route,
            string name,
            string package,
            string action,
            bool result,
            bool sslVerify,
            int timeout,
            string apiKey,
            string server,
            string authUri)
        {
            HttpMethods = httpMethods ?? throw new ArgumentNullException(nameof(httpMethods));
            Route = route ?? throw new ArgumentNullException(nameof(route));
            Name = name ?? throw new ArgumentNullException(nameof(name));
            Package = package ?? throw new ArgumentNullException(nameof(package));
            Action = action ?? throw new ArgumentNullException(nameof(action));
            Result = result;
            SslVerify = sslVerify;
            Timeout = timeout;
            ApiKey = apiKey ?? throw new ArgumentNullException(nameof(apiKey));
            Server = server ?? throw new ArgumentNullException(nameof(server));
            AuthUri = authUri ?? throw new ArgumentNullException(nameof(authUri));
        }
    }
}
----- END OF OWUtils\OpenWhiskFunctionDescriptor.cs -----
----- START OF OWUtils\OpenWhiskUtilities.cs -----
using Newtonsoft.Json.Linq;
using System;
using System.IO;
using System.Net.Http;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using OW;
using OWMicroservices;
using Newtonsoft.Json;

/// <summary>
/// Custom attribute for annotating OpenWhisk element parameters actions.
/// </summary>
[AttributeUsage(AttributeTargets.Class)]

public class ServerAttribute : Attribute
{
    /// <summary>
    ///     Gets the name of the action.
    ///     The name is used to identify the where is located the api.
    /// </summary>
    public string Name { get; private set; }

    /// <summary>
    /// Initializes a new instance of the ActionAttribute class with the specified name.
    /// </summary>
    /// <param name="name"></param>
    public ServerAttribute(string name)
    {
        Name = name;
    }
}

public class AuthUriAttribute : Attribute
{
    /// <summary>
    ///     Gets the name of the AuthUriAttribute.
    ///     The name is used to identify the action for get jwt token.
    /// </summary>
    public string Name { get; private set; }

    /// <summary>
    /// Initializes a new instance of the AuthUriAttribute class with the specified name.
    /// </summary>
    /// <param name="name"></param>
    public AuthUriAttribute(string name)
    {
        Name = name;
    }
}

public class ActionAttribute : Attribute
{
    /// <summary>
    ///     Gets the name of the action.
    ///     The name is used to identify the action in the OpenWhisk system.
    ///     The name is required and must be unique within the package that contains the action.
    ///     The name can be qualified using a namespace, such as /whisk.system/utils/echo.
    ///     The namespace must be unique within the system.
    ///     The name and namespace cannot be changed after an action is created.
    ///     The name must be at least 1 character and no more than 128 characters.
    ///     The name can contain letters (a-z), numbers (0-9), dashes (-), and underscores (_).
    ///     The name cannot begin with a dash.
    ///     The name cannot begin or end with an underscore.
    ///     The name cannot contain two or more consecutive dashes.
    ///     The name cannot contain two or more consecutive underscores.
    ///     The name cannot contain spaces.
    ///     The name cannot contain any other special characters.
    /// </summary>
    public string Name { get; private set; }

    /// <summary>
    /// Initializes a new instance of the ActionAttribute class with the specified name.
    /// </summary>
    /// <param name="name"></param>
    public ActionAttribute(string name)
    {
        Name = name;
    }
}

/// <summary>
/// Custom attribute for annotating OpenWhisk element parameters packages.
/// </summary>
[AttributeUsage(AttributeTargets.Class)]
public class PackageAttribute : Attribute
{
    /// <summary>
    ///    Gets the name of the package.
    ///    The name is used to identify the package in the OpenWhisk system.
    ///    The name is required and must be unique within the system.
    ///    The name cannot be changed after a package is created.
    ///    The name can be qualified using a namespace, such as /whisk.system/utils.
    ///    The namespace must be unique within the system.
    ///    The name and namespace cannot be changed after a package is created.
    ///    The name must be at least 1 character and no more than 128 characters.
    ///    The name can contain letters (a-z), numbers (0-9), dashes (-), and underscores (_).
    ///    The name cannot begin with a dash.
    ///    The name cannot begin or end with an underscore.
    ///    The name cannot contain two or more consecutive dashes.
    ///    The name cannot contain two or more consecutive underscores.
    ///    The name cannot contain spaces.
    ///    The name cannot contain any other special characters.
    /// </summary>
    public string Name { get; private set; }

    /// <summary>
    /// Initializes a new instance of the PackageAttribute class with the specified name.
    /// </summary>
    public PackageAttribute(string name)
    {
        Name = name;
    }
}

/// <summary>
/// Custom attribute for annotating APISIX element parameters routes.
/// </summary>
[AttributeUsage(AttributeTargets.Class)]
public class RouteAttribute : Attribute
{
    /// <summary>
    /// Gets the PATH of the route for APISIX system.
    /// </summary>
    public string Name { get; private set; }

    /// <summary>
    /// Initializes a new instance of the RouteAttribute class with the specified name.
    /// </summary>
    public RouteAttribute(string name)
    {
        Name = name;
    }
}

namespace OW
{
    /// <summary>
    /// Provides utility functions to interact with OpenWhisk actions and Apisix routes.
    /// </summary>
    public static class OpenWhiskUtilities
    {
        private static readonly HttpClient client = new HttpClient();
        private static readonly string contapiHost = "http://controller:3233";
        private static readonly string jwtApiKey = "edd1c9f034335f136f87ad84b625c8f1";
        private static readonly string apisixAdminPattern = "http://apisix-admin:9280/apisix/admin/routes/{0}";

        /// <summary>
        /// Helper method that extracts the value of a specified attribute property or returns a default error message.
        /// </summary>
        /// <typeparam name="T">The Attribute type to extract from.</typeparam>
        /// <param name="attributes">An IEnumerable of Attribute instances to search within.</param>
        /// <param name="attributeName">The name of the property to extract from the attribute.</param>
        /// <returns>The extracted value as a string or an error message.</returns>
        public static string GetAttributeValue(string attributeName)
        {
            Type type = typeof(MyMicroservicesOpenWhiskExecutor);

            switch (attributeName)
            {
                case "Action":
                    return type.GetCustomAttribute<ActionAttribute>()?.Name ?? $"ERRORE_{attributeName}_NON_TROVATO";
                case "Package":
                    return type.GetCustomAttribute<PackageAttribute>()?.Name ?? $"ERRORE_{attributeName}_NON_TROVATO";
                case "Route":
                    return type.GetCustomAttribute<RouteAttribute>()?.Name ?? $"ERRORE_{attributeName}_NON_TROVATO";
                case "AuthUri":
                    return type.GetCustomAttribute<AuthUriAttribute>()?.Name ?? $"ERRORE_{attributeName}_NON_TROVATO";
                case "Server":
                    return type.GetCustomAttribute<ServerAttribute>()?.Name ?? $"ERRORE_{attributeName}_NON_TROVATO";
                default:
                    return $"ERRORE_{attributeName}_NON_TROVATO";
            }

        }

        /// <summary>
        /// Extracts the line number from an exception's stack trace.
        /// </summary>
        /// <param name="ex">The Exception to analyze.</param>
        /// <returns>A nullable int representing the parsed line number, or null if it cannot be parsed.</returns>
        public static int? GetLineNumberFromStackTrace(Exception ex)
        {
            // Safely attempt to obtain the stack trace from the Exception object
            string? stackTrace = ex.StackTrace;
            if (!string.IsNullOrWhiteSpace(stackTrace))
            {
                // Attempt to locate and parse the line number from the stack trace
                int index = stackTrace.LastIndexOf("line ", StringComparison.OrdinalIgnoreCase);
                if (index != -1 && int.TryParse(stackTrace[(index + "line ".Length)..], out int lineNumber))
                {
                    return lineNumber;
                }
            }
            // Return null if the line number could not be determined
            return null;
        }

        /// <summary>
        /// Static constructor to initialize http client with default headers.
        /// </summary>
        static OpenWhiskUtilities()
        {
            client.DefaultRequestHeaders.Add("x-api-key", jwtApiKey);
        }

        /// <summary>
        /// Asynchronously sets up an Apisix route for an OpenWhisk function.
        /// </summary>
        /// <param name="descriptor">OpenWhiskFunctionDescriptor object containing details about the function.</param>
        /// <returns>A JObject containing the result of the setup operation.</returns>
        public static async Task<JObject> SetupRouteInApisix(OpenWhiskFunctionDescriptor descriptor)
        {
            var apisixAdminUrl = string.Format(apisixAdminPattern, descriptor.Name);

            // Read the template for the request body transformation from embedded resources.
            string embeddedtemplate = await ReadEmbeddedTemplate("OpenWhisk_MicroAPI.OWUtils");

            // Construct configuration object for the route setup.
            var routeConfig = new
            {
                plugins = new Dictionary<string, object>
                {
                    ["jwt-auth"] = new { _meta = new { disable = false } },
                    ["openwhisk"] = new
                    {
                        api_host = contapiHost,
                        service_token = descriptor.ApiKey,
                        @namespace = "nuvolaris",
                        action = descriptor.Action,
                        package = descriptor.Package,
                        result = descriptor.Result,
                        ssl_verify = descriptor.SslVerify,
                        timeout = descriptor.Timeout
                    },
                    ["body-transformer"] = new
                    {
                        request = new { template = embeddedtemplate }
                    }
                },
                methods = descriptor.HttpMethods,
                name = descriptor.Name,
                uri = $"{descriptor.Route}{descriptor.Action}"
            };

            // Serialize configuration object and send Put request to Apisix.
            var content = new StringContent(
                JObject.FromObject(routeConfig).ToString(),
                Encoding.UTF8,
                "application/json");

            try
            {
                var response = await client.PutAsync(apisixAdminUrl, content);
                if (!response.IsSuccessStatusCode)
                {
                    // Return an error object if response status is not successful.
                    return new JObject { ["error"] = await response.Content.ReadAsStringAsync(), ["sended_body"] = JObject.FromObject(routeConfig) };
                }
                var respcont = JObject.Parse(await response.Content.ReadAsStringAsync());
                var openapiSpec = GenerateOpenApiSpec(respcont, descriptor);
                // Return success object including the route configuration sent.
                return new JObject
                {
                    ["success"] = respcont,
                    ["openapi_spec"] = openapiSpec,
                    ["sended_body"] = JObject.FromObject(routeConfig)
                };
            }
            catch (HttpRequestException e)
            {
                // Catch and return HttpRequestException details as error.
                return new JObject { ["error"] = e.Message };
            }
        }

        /// <summary>
        /// Generates OpenAPI specification for the OpenWhisk function based on the setup result.
        /// </summary>
        /// <param name="setupResult">Result from setting up the Apisix route as JObject.</param>
        /// <param name="descriptor">Details of the OpenWhisk function.</param>
        /// <returns>OpenAPI Specification as JObject.</returns>
        public static JObject GenerateOpenApiSpec(JObject setupResult, OpenWhiskFunctionDescriptor descriptor)
        {
            string OpenApiPath = GeneratePathForMethod(descriptor);
            // Create the base structure for OpenAPI spec.
            var openApiSpec = new JObject
            {
                ["openapi"] = "3.0.0",
                ["info"] = new JObject { ["title"] = descriptor.Name, ["version"] = "1.0.0" },
                ["servers"] = new JArray(new JObject { ["url"] = descriptor.Server }),
                ["securitySchemes"] = new JObject // Aggiungi lo schema di sicurezza
                {
                    ["bearerAuth"] = new JObject
                    {
                        ["type"] = "http",
                        ["scheme"] = "bearer",
                        ["bearerFormat"] = "JWT",
                        ["description"] = $"JWT token can be obtained from {descriptor.Server}{descriptor.AuthUri}"
                    }
                }
            };
            openApiSpec["paths"] = new JObject{ [OpenApiPath] = new JObject()};

            // Generate path item object for each HTTP method supported.
            foreach (var method in descriptor.HttpMethods)
            {
                // Utilizzo di GeneratePathItem per ogni metodo
                JObject genpathitem = GeneratePathItem(method, descriptor);

                #pragma warning disable CS8602 // Dereference of a possibly null reference.
                    openApiSpec["paths"][OpenApiPath][method.ToLower()] = genpathitem;
                #pragma warning restore CS8602 // Dereference of a possibly null reference.

            }

            // Creare lo schema per FncDto
            var fncDtoSchema = new JObject();
            foreach (var prop in typeof(FncDto).GetProperties())
            {
                fncDtoSchema[prop.Name] = new JObject
                {
                    ["type"] = prop.PropertyType.Name.ToLower()
                };
            }


            openApiSpec["components"] = new JObject
            {
                ["schemas"] = new JObject
                {
                    ["FncDto"] = new JObject
                    {
                        ["schema"] = new JObject
                        {

                            ["type"] = "object",
                            ["properties"] = fncDtoSchema
                        }
                    }
                }
            };

            return openApiSpec;
        }

        /// <summary>
        /// Generates path item information for a given HTTP method.
        /// </summary>
        /// <param name="httpMethod">HTTP method for which to generate the path item.</param>
        /// <returns>JObject that represents the path item.</returns>
        private static JObject GeneratePathItem(string httpMethod, OpenWhiskFunctionDescriptor descriptor)
        {
            var requestbody = new JObject();
            var parameters = new JArray();
            if (httpMethod.ToLower() == "post")
            {
                parameters = null;
                requestbody = new JObject
                {
                    ["content"] = new JObject
                    {
                        ["application/json"] = new JObject
                        {
                            ["schema"] = new JObject{
                                ["$ref"] = "#/components/schemas/FncDto"
                            },
                            ["example"] = JObject.FromObject(new FncDto())
                        }
                    }
                };
            }
            if (httpMethod.ToLower() == "put")
            {
                parameters = null;
                requestbody = new JObject
                {
                    ["content"] = new JObject
                    {
                        ["application/json"] = new JObject
                        {
                            ["schema"] = new JObject{
                                ["$ref"] = "#/components/schemas/FncDto"
                            },
                            ["example"] = JObject.FromObject(new FncDto())
                        }
                    }
                };
            }
            if (httpMethod.ToLower() == "patch")
            {
                parameters = null;
                requestbody = new JObject
                {
                    ["content"] = new JObject
                    {
                        ["application/json"] = new JObject
                        {
                            ["schema"] = new JObject{
                                ["$ref"] = "#/components/schemas/FncDto"
                            },
                            ["example"] = JObject.FromObject(new FncDto())
                        }
                    }
                };
            }
            if (httpMethod.ToLower() == "delete")
            {
                requestbody = null;
                parameters = new JArray(new JObject
                {
                    ["in"] = "query",
                    ["name"] = typeof(FncDto).GetProperties()[0].Name,
                    ["schema"] = new JObject
                    {
                        ["type"] = typeof(FncDto).GetProperties()[0].PropertyType.Name.ToLower()
                    },
                    ["description"] = "Table ID"
                });

            }
            if (httpMethod.ToLower() == "get")
            {
                requestbody = null;
                parameters = new JArray(new JObject
                {
                    ["in"] = "query",
                    ["name"] = typeof(FncDto).GetProperties()[0].Name,
                    ["schema"] = new JObject
                    {
                        ["type"] = typeof(FncDto).GetProperties()[0].PropertyType.Name.ToLower()
                    },
                    ["description"] = "Table ID"
                });
            }
            // Costruisci l'oggetto path item con dettagli di riepilogo e risposta.
            var pathItem = new JObject
            {

                    ["tags"] = new JArray(descriptor.Name),
                    ["operationId"] = $"{descriptor.Name}_{httpMethod.ToLower()}",
                    ["summary"] = $"API for {httpMethod.ToUpper()}",
                    ["description"] = $"API for {httpMethod.ToUpper()}",
                    ["parameters"] = new JArray(),
                    ["responses"] = new JObject
                    {
                        ["200"] = new JObject
                        {
                            ["description"] = "Successful response",
                            ["content"] = new JObject
                            {
                                ["application/json"] = new JObject
                                {
                                    ["schema"] = new JObject{
                                        ["$ref"] = "#/components/schemas/FncDto"
                                    },
                                    ["example"] = JObject.FromObject(new FncDto())
                                }
                            }
                        }
                    },
                    ["x-examples"] = new JObject(),
                    ["security"] = new JArray(new JObject { ["bearerAuth"] = new JArray() }) // Aggiungi informazioni di sicurezza JWT

            };

            if (requestbody is not null){
                    pathItem["requestBody"] = requestbody;
            }
            if (parameters is not null){
                    pathItem["parameters"] = parameters;
            }
            // Genera il comando cURL
            string curlExample = GenerateCurlExample(httpMethod, descriptor);
            if (pathItem["x-examples"] != null)
            {
                #pragma warning disable CS8602 // Dereference of a possibly null reference.
                    pathItem["x-examples"]["curl"] = curlExample;
                #pragma warning restore CS8602 // Dereference of a possibly null reference.
            }

            return pathItem;
        }

        private static string GenerateCurlExample(string httpMethod, OpenWhiskFunctionDescriptor descriptor)
        {
            // Genera l'URL completo per la chiamata API
            string apiUrl = $"{descriptor.Server}{descriptor.Route}{descriptor.Name}";

            // Costruisci il comando cURL
            var curlBuilder = new StringBuilder();
            curlBuilder.Append($"curl -X {httpMethod.ToUpper()} \"{apiUrl}\"");

            // Aggiungi headers
            curlBuilder.Append(" -H \"Content-Type: application/json\"");

            // Aggiungi autenticazione JWT o altri headers se necessario
            curlBuilder.Append(" -H \"Authorization: Bearer YOUR_JWT_TOKEN\"");

            // Determina e aggiunge il body della richiesta in base al metodo HTTP
            string requestBody;
            switch (httpMethod.ToLower())
            {
                case "put":
                case "patch":
                    // Serializza il DTO in formato JSON
                    requestBody = JsonConvert.SerializeObject(new FncDto()); // Usa il tuo DTO qui
                    break;
                case "post":
                    // Utilizza un body di esempio key-value per POST
                    requestBody = "{\"key1\":\"value1\", \"key2\":\"value2\"}";
                    break;
                default:
                    requestBody = "";
                    break;
            }

            // Aggiungi il body della richiesta se necessario
            if (!string.IsNullOrEmpty(requestBody))
            {
                curlBuilder.Append($" -d '{requestBody}'");
            }

            // Aggiungi autenticazione JWT o altri headers se necessario
            curlBuilder.Append(" -H \"Authorization: Bearer YOUR_JWT_TOKEN\"");

            return curlBuilder.ToString();
        }

        public static string GeneratePathForMethod( OpenWhiskFunctionDescriptor descriptor)
        {
            // Potresti voler modificare il percorso in base al metodo HTTP
            return $"{descriptor.Route}{descriptor.Name}";

        }


        /// <summary>
        /// Reads an embedded template file asynchronously.
        /// </summary>
        /// <param name="resourceFileName">The name of the resource file to be read.</param>
        /// <returns>The contents of the embedded resource file as a string.</returns>
        private static async Task<string> ReadEmbeddedTemplate(string resourceFileName)
        {

            var assembly = Assembly.GetExecutingAssembly();

            using (var stream = assembly.GetManifestResourceStream($"{resourceFileName}.template.lua"))
            {
                if (stream == null)
                {
                    // Crea un StringBuilder per accumulare i nomi delle risorse
                    StringBuilder sb = new StringBuilder();
                    sb.AppendLine("ERRORE_LETTURA_TEMPLATE: FILE NON TROVATO. " + $"{resourceFileName}.template.lua");

                    // Ottieni e aggiungi tutti i nomi delle risorse incorporate
                    string[] resourceNames = assembly.GetManifestResourceNames();
                    foreach (string resourceName in resourceNames)
                    {
                        sb.AppendLine(resourceName);
                    }

                    // Restituisce l'elenco delle risorse
                    return sb.ToString();
                }

                using (var reader = new StreamReader(stream))
                {
                    // Leggi e restituisci l'intero contenuto del file di risorsa incorporato
                    return await reader.ReadToEndAsync();
                }
            }
        }
    }
}
----- END OF OWUtils\OpenWhiskUtilities.cs -----
----- START OF obj\Debug\net7.0\OpenWhisk_MicroAPI.AssemblyInfo.cs -----
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("OpenWhisk_MicroAPI")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("OpenWhisk_MicroAPI")]
[assembly: System.Reflection.AssemblyTitleAttribute("OpenWhisk_MicroAPI")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.

----- END OF obj\Debug\net7.0\OpenWhisk_MicroAPI.AssemblyInfo.cs -----
----- START OF obj\Debug\net7.0\OpenWhisk_MicroAPI.GlobalUsings.g.cs -----
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
----- END OF obj\Debug\net7.0\OpenWhisk_MicroAPI.GlobalUsings.g.cs -----
----- START OF obj\Release\net7.0\OpenWhisk_MicroAPI.AssemblyInfo.cs -----
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("OpenWhisk_MicroAPI")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("OpenWhisk_MicroAPI")]
[assembly: System.Reflection.AssemblyTitleAttribute("OpenWhisk_MicroAPI")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generato dalla classe WriteCodeFragment di MSBuild.

----- END OF obj\Release\net7.0\OpenWhisk_MicroAPI.AssemblyInfo.cs -----
----- START OF obj\Release\net7.0\OpenWhisk_MicroAPI.GlobalUsings.g.cs -----
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
----- END OF obj\Release\net7.0\OpenWhisk_MicroAPI.GlobalUsings.g.cs -----
